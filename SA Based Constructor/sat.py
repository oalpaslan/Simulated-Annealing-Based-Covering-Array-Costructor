# -*- coding: utf-8 -*-
"""sim_ann_test.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1pdrTcaTZPs-m38Li-FN6Omp8aHVymcX3
"""

from operator import ne
import sys
from types import new_class
import numpy as np
from numpy import asarray
from numpy import unique
import xml.dom.minidom
import time
import itertools
from itertools import combinations
from itertools import product
import random
import math
import xml.etree.ElementTree as ET
from numpy.core.defchararray import _to_string_or_unicode_array
from numpy.core.getlimits import _register_type
import scipy
from scipy.constants import k
from scipy import special


def find_max_size(t, no_opts, val_ct):  # Upper bound of the size
    top = np.log(bino_coef(no_opts, t)) + (t * np.log(t))
    bottom = np.log((val_ct) / (val_ct - 1))
    return int(top / bottom) + 1


def bino_coef(n, k):  # Binomial coefficient function
    if 0 <= k <= n:
        ntok = 1
        ktok = 1
        for t in range(1, min(k, n - k) + 1):
            ntok *= n
            ktok *= t
            n -= 1
        return ntok // ktok
    else:
        return 0


def create_array(mydict, constraints):
    arr = []
    prod = my_product(mydict)
    # Takes the cartesian product of options with values. This will create a configuration settings list.
    for i in prod:
        first_arr = np.array([])
        for val in i.values():
            first_arr = np.append(first_arr, val)
        if check_constraints(first_arr, mydict, constraints):
            arr.append(list(i.values()))

    return asarray(arr)  # This will return the arr with the numpy array form.


def my_product(mydict):
    return (dict(zip(mydict, x)) for x in product(*mydict.values()))


def create_test_array(array, size):
    x = sorted(random.sample(range(array.shape[0]), min(size, array.shape[0])))
    return array[x, :]


def count_miss(data, t, mydict):
 # print(np.arange(data.shape[1]))
    missing_tuples = 0
    # combinations(): itertools module, creates an array of all the given t combinations of the values
    for p in combinations(np.arange(data.shape[1]), t):
        # check if every possible interaction is represented
        mult = 1
        for i in range(0, t):
            mult *= len(mydict[('o' + str(p[i]+1)), str(p[i])])
        if (np.unique(data[:, p], axis=0).shape[0] < mult):
            missing_tuples = mult - np.unique(data[:, p], axis=0).shape[0]
            return missing_tuples
    # if we made it through the whole for loop, return true
    return missing_tuples


def check_constraints(data, mydict, constraints):
    for x in constraints:
        ind = []
        inv_ind = []
        for opt in constraints[x]:
            # i = 0  # For saving the column orders to be keys of conc_dict
            for y in mydict.keys():
                if len(opt) == 2:  # If the configuration in constraint is an equality condition
                    if opt[0] == y[0]:
                        ind.append(data[int(y[1])])
                elif len(opt) == 3:
                    if opt[0] == y[0]:
                        ind.append(("!", data[int(y[1])]))
            inv_ind = np.append(inv_ind, opt[1])
        if len(ind[0]) == 1 and len(ind[1]) == 1:
            if ind[0] == inv_ind[0]:
                if ind[1] != inv_ind[1]:
                    return False
        elif len(ind[0]) == 2 and len(ind[1]) == 1:
            if ind[0][1] != inv_ind[0]:
                if ind[1] != inv_ind[1]:
                    return False
        elif len(ind[0]) == 1 and len(ind[1]) == 2:
            if ind[0] == inv_ind[0]:
                if ind[1][1] == inv_ind[1]:
                    return False
        elif len(ind[0]) == 2 and len(ind[1]) == 2:
            if ind[0][1] != inv_ind[0]:
                if ind[1][1] == inv_ind[1]:
                    return False
        # if len(ind) == 2:
        #     for k in range(0, len(ind)):

        #         f_row = int(ind[0])
        #         r_opt = int(opt[1])
        #         print("Z[k]:", f_row)
        #         print("OPT[1]:", r_opt)
        #         if f_row == opt[1] and:
        #             print("çalıştı")
        #             conc_dict = np.append(conc_dict, k)
        #     for kk in range(0, len(colmns)):
        #         f_row1 = int(colmns[1])
        #         r_opt1 = int(opt[1])
        #         print("Z[kk]:", f_row1)
        #         print("OPT[1]:", r_opt1)
        #         if r_opt1 != f_row1:
        #             not_conc = np.append(not_conc, kk)
        #     print("Bakalım", conc_dict)
        #     # !!! NEDEN DUPLICATE ÇIKMIYOR? ROWLARI KAYDETMEDE HATA VAR DÜZELT!!! ASLA TRUE OLMUYOR
        #     for conc in conc_dict:
        #         if conc in not_conc:
        #             return False
        #         else:
        #             return True
    return True


def check_interactions(data, mydict, constraints, t):

    # combinations(): itertools module, creates an array of all the given t combinations of the values
    for p in combinations(np.arange(data.shape[1]), t):
        # check if every possible interaction is represented

        mult = 1
        for i in range(0, t):
            # print(len(mydict[str(p[i])]))
            mult *= len(mydict[('o' + str(p[i]+1)), str(p[i])])

            # t VALUE SAYISI ÇARPILARAK BU DEĞER BULUNABİLİR
        # if -> or check_constraints(data, mydict, constraints) == False
        if (unique(data[:, p], axis=0).shape[0] < mult or check_constraints(data, mydict, constraints) == False):
            # if not, return false
            return False
    # if we made it through the whole for loop, return true
    return True


def cooling_rate(starting_temp, stopping_temp, t, no_opts):
    top = (starting_temp - stopping_temp)
    bottom = 0.15 * ((10**t) * no_opts * t)

    return (top/bottom)


def size_decrease(data):  # Randomly deletes a row in generated array to decrease its size
    dec_data = np.delete(data, random.randint(0, data.shape[0]), 0)
    return dec_data


# Neighboring state generation function which gets the data and alters an option setting value
def neighboring_state_gen(data, no_opts, mydict, c_size, constraints):
    cons = False
    if data.shape[0] == c_size:
        neighbor = data
        while cons == False:
            c_row = random.randint(0, data.shape[0]-1)
            c_col = random.randint(0, no_opts-1)
            c_c_row = len(mydict[('o'+str(c_col+1)), str(c_col)])
            rand_ind = random.randint(0, c_c_row-1)
            if check_constraints(data[c_row], mydict, constraints):
                neighbor[c_row, c_col] = rand_ind
                cons = True
    else:
        neighbor = create_test_array(data, c_size)
    return neighbor


doc = xml.dom.minidom.parse(input('Please enter the name of the XML file: '))
mydict = {}
constraints = {}
cns_arr = []
ptr = 0
for node in doc.getElementsByTagName('Parameter'):
    if node.hasChildNodes():
        (name, id) = (node.getAttribute('name'), node.getAttribute('id'))
        values = node.getElementsByTagName('value')
        x = []
        for value in values:
            x += value.firstChild.nodeValue
        mydict[name, id] = x
for node2 in doc.getElementsByTagName('Constraint'):
    c_text = node2.getAttribute('text')
    constraints[ptr] = c_text
    ptr += 1
for cns in constraints:
    cns_arr.append(constraints[cns].split(' => '))
print(constraints[0].split('=>')[0])
cns_arr = np.asarray(cns_arr)
arranged_cns = {}
count = 0
for x in cns_arr:
    for y in x:
        if '!=' in y:
            sp_y = y.split('!=')
            sp_y.append('!')
            if count in arranged_cns.keys():
                arranged_cns[count].append(sp_y)
            else:
                arranged_cns[count] = [sp_y]
        elif '=' in y:
            spi_y = y.split('=')
            if count in arranged_cns.keys():
                arranged_cns[count].append(spi_y)
            else:
                arranged_cns[count] = [spi_y]
    count += 1
print(arranged_cns)
arr = create_array(mydict, arranged_cns)
print(arr)
t = int(input('Coverage strength(t): '))
# no_opts = int(input('Number of options: '))
# no_vals = int(input('Number of option values for every option: '))
count = 0
value_count = 1
for x in mydict.values():
    value_count *= len(x)
no_opts = len(mydict)
# no_vals = value_count
starting_temp = 10
stopping_temp = 0.000001
running = 100

# arr = create_array(no_opts, no_vals)
c_size = find_max_size(t, no_opts, value_count)
print(c_size)
test = create_test_array(arr, c_size)
while not check_constraints(test, mydict, arranged_cns):
    test = create_test_array(arr, c_size)
working_test = test
# while check_constraints(working_test, mydict, arranged_cns):
#     working_test = create_test_array(working_test, c_size)
print("Test array: ", working_test)
if check_interactions(working_test, mydict, arranged_cns, t):
    miss = count_miss(test, t, mydict)
    if (miss == 0):
        best = test
        first_array = best
# while (running > 0):
#     test = create_test_array(arr, c_size)
#     # check if all interactions are represented in this test array
#     if (check_interactions(test, arranged_cns, mydict, t)):
#         # if they are, reduce the covariance size and try again
#         c_size = c_size - 1
#         working_test = test
#     else:
#         # else, the iterations if we have a working test
#         if (working_test.shape[0] != 0):
#             running = running - 1
first_array = best = working_test
print("First array:\n", working_test)
print("Covering array size: ", working_test.shape[0], working_test.shape[1],
      " with the total of ", working_test.shape[0] * working_test.shape[1], " indices.")
print(". . .")
c_rate = cooling_rate(starting_temp, stopping_temp, t, no_opts)
temp = starting_temp
# working_test = create_test_array(test, c_size)
start = time.time()
c_size = working_test.shape[0]
while temp > stopping_temp:
    working_test = create_test_array(working_test, c_size)
    miss = count_miss(working_test, t, mydict)
    if (miss == 0):
        best = working_test
        c_size -= 1
        temp = starting_temp
        continue
    neighbor = neighboring_state_gen(
        working_test, no_opts, mydict, c_size, arranged_cns)
    t_miss_n = count_miss(neighbor, t, mydict)
    diff_miss = t_miss_n - miss
    if check_constraints(neighbor, mydict, arranged_cns) == True and (working_test.shape[0] == neighbor.shape[0] or (diff_miss < 0 or (random.randint(0, 1) < (math.e)**((-(scipy.constants.k))*diff_miss/temp)))):
        working_test = neighbor
        if count_miss(working_test, t, mydict) == 0:
            best = working_test
            c_size -= 1
            temp = starting_temp
            continue
    temp = temp - (temp * c_rate)
stop = time.time()
print(stop-start)
c_array = np.unique(best, axis=0)
if c_array.size < first_array.size:
    print(check_constraints(c_array, mydict, arranged_cns))
    print("Final missing tuple count: ", count_miss(best, t, mydict))
    print(c_array)
    print("First covering array size: ", c_array.shape[0], c_array.shape[1],
          " with the total of ", c_array.shape[0] * c_array.shape[1], " indices.")
else:
    print(first_array)
    print("Final missing tuple count: ",
          count_miss(first_array, t, mydict))
    print("Covering array size: ", first_array.shape[0], first_array.shape[1],
          " with the total of ", first_array.shape[0] * first_array.shape[1], " indices.")
